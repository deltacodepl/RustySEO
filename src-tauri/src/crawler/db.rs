use chrono::Utc;
use directories::ProjectDirs;
use rusqlite::{params, Connection, Result};
use serde::{Deserialize, Serialize};
use serde_json;
use std::fs;

mod models;

#[derive(Serialize, Deserialize, Debug)]
pub struct PageSpeedDB {
    pub id: String,
    pub lighthouse_result: LighthouseResult,
    // Add other fields as needed
}

#[derive(Serialize, Deserialize, Debug)]
pub struct LighthouseResult {
    pub categories: Categories,
    pub audits: Audits,
    // Add other fields as needed
}

#[derive(Serialize, Deserialize, Debug)]
pub struct Categories {
    pub performance: Performance,
    // Add other categories as needed
}

#[derive(Serialize, Deserialize, Debug)]
pub struct Performance {
    pub score: f64,
    // Add other fields as needed
}

#[derive(Serialize, Deserialize, Debug)]
pub struct Audits {
    #[serde(rename = "first-contentful-paint")]
    pub first_contentful_paint: Audit,
    #[serde(rename = "speed-index")]
    pub speed_index: Audit,
    // Add other audits as needed
}

#[derive(Serialize, Deserialize, Debug)]
pub struct Audit {
    pub id: String,
    pub title: String,
    pub description: String,
    pub score: Option<f64>,
    // Add other fields as needed
}

#[derive(Serialize, Deserialize, Debug)]
pub struct CrawledData {
    pub id: Option<i64>, // Add id as Option to handle inserts where id is not available
    pub url: String,
    pub text: String,
    pub date: String,       // Date as String
    pub title: Vec<String>, // Vector to store as JSON
}

pub fn open_db_connection() -> Result<Connection, rusqlite::Error> {
    // Retrieve the config directory for the application
    let project_dirs = ProjectDirs::from("com", "YourCompany", "YourAppName")
        .ok_or_else(|| rusqlite::Error::QueryReturnedNoRows)?;

    // Define the directory for the DB file
    let db_dir = project_dirs.data_dir(); // Use data_dir() for application data
    let db_path = db_dir.join("crawl_results.db");

    println!("Project directories: {:?}", project_dirs);
    println!("DB directory: {:?}", db_dir);
    println!("DB path: {:?}", db_path);

    // Ensure the directory exists
    if !db_dir.exists() {
        fs::create_dir_all(db_dir).expect("Failed to create directory");
    }

    // Create a new SQLite database connection
    Connection::open(&db_path)
}

pub fn create_table() -> Result<Connection, rusqlite::Error> {
    let conn = open_db_connection()?;

    // Create the table if it does not exist
    conn.execute(
        "CREATE TABLE IF NOT EXISTS results (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            date TEXT,
            url TEXT NOT NULL,
            strategy TEXT,
            performance TEXT
        )",
        [],
    )
    .expect("Failed to create table");

    Ok(conn)
}

pub fn add_crawled_data(url: &str, title: &Vec<String>) -> Result<(), rusqlite::Error> {
    let date = Utc::now().naive_utc().to_string(); // Convert NaiveDateTime to string

    // Serialize the vector as a JSON string
    let title_json = serde_json::to_string(title).expect("Failed to serialize title");

    let conn = create_table()?;

    let data = CrawledData {
        id: None, // ID will be auto-generated by SQLite
        url: url.to_string(),
        text: "Hello, world!".to_string(),
        date,
        title: title.clone(), // No need to convert again
    };

    Ok(())
}

// Function to read data from the database
pub fn read_data_from_db() -> Result<Vec<CrawledData>, rusqlite::Error> {
    let conn = open_db_connection()?;
    let mut stmt = conn.prepare("SELECT * FROM results")?;

    let results = stmt.query_map([], |row| {
        // Deserialize title from JSON string to Vec<String>
        let title_json: String = row.get(5)?;
        let title: Vec<String> =
            serde_json::from_str(&title_json).expect("Failed to deserialize title");

        Ok(CrawledData {
            id: row.get(0)?,
            url: row.get(1)?,
            text: row.get(3)?,
            date: row.get(4)?,
            title,
        })
    })?;

    let mut data = Vec::new();
    for result in results {
        data.push(result?);
    }

    Ok(data)
}

pub fn add_data_from_pagespeed(data: &str) {
    let conn =
        open_db_connection().expect("Failed to open database connection for page speed insights");

    match serde_json::from_str::<models::PageSpeedResponse>(data) {
        Ok(mut parsed_data) => {
            println!(
                "Parsed data: {:#?}",
                parsed_data.lighthouse_result.categories.performance.score
            );

            let score = parsed_data.lighthouse_result.categories.performance.score;
            // Insert data into the results table
            conn.execute("INSERT INTO results (score) VALUES (?5)", params![score]);

            println!("Data added");
        }
        Err(e) => {
            println!("Error: {}", e);
        }
    }
}
